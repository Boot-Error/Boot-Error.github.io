<!DOCTYPE html>
<html lang="en-US">
  <head>
	  
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title></title>
<meta property="og:title" content="Ramblings from Vighnesh" />
<meta property="og:type" content="website" />
<meta property="og:url" content="" />
<meta property="og:image" content="flying_toaster.jpg" />
<meta property="og:description" content="">
<link rel="canonical" href="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hack/0.8.1/hack.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hack/0.8.1/dark.css">
<style>
a::after,
a[rel*="external"] {
  content: " " url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20class='i-external'%20viewBox='0%200%2032%2032'%20width='14'%20height='14'%20fill='none'%20stroke='%23ff9800'%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='9.38%'%3E%3Cpath%20d='M14%209%20L3%209%203%2029%2023%2029%2023%2018%20M18%204%20L28%204%2028%2014%20M28%204%20L14%2018'/%3E%3C/svg%3E");
}
</style>

  </head>
  <body class="hack dark main container">
    <header>
  
  <nav>
    
    
      <a class="" href="/">Home</a>
    
      <a class="" href="/about/">About</a>
    
      <a class="active" href="/post/">Posts</a>
    
  </nav>


</header>
    <main>
  <h1>cracker_barrel - AUCTF writeup</h1>
  
  
	<a href="https://boot-error.github.io/tags/ctf-writeup/">ctf-writeup</a>
  
	<a href="https://boot-error.github.io/tags/radare/">radare</a>
  
	<a href="https://boot-error.github.io/tags/reversing/">reversing</a>
  
  <br/>
  <br/>
  <details>
	  <summary>Table of Contents</summary>
	  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#recon">recon</a></li>
        <li><a href="#solving-check_1">solving <code>check_1</code></a></li>
        <li><a href="#solving-check_2">solving <code>check_2</code></a></li>
        <li><a href="#solving-check_3">solving <code>check_3</code></a></li>
        <li><a href="#the-result">The result</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </details>
  
  <p>In <a href="https://ctf.auburn.edu/">AUCTF 2020</a> under <code>rev</code> section, the challenge <a href="https://github.com/auehc/AUCTF-2020/blob/master/Reversing/Cracker%20Barrel/prompt.md">cracker barrel</a> had a binary given running on remote.</p>
<p>Let&rsquo;s rev it up.</p>
<h3 id="recon">recon</h3>
<pre><code class="language-radare2" data-lang="radare2">o cracker_barrel
aaa
i
</code></pre><pre><code>fd       6
file     cracker_barrel
size     0x43e8
humansz  17.0K
mode     r-x
format   elf64
iorw     false
blksz    0x0
block    0x100
type     DYN (Shared object file)
arch     x86
baddr    0x0
binsz    15399
bintype  elf
bits     64
canary   true
class    ELF64
compiler GCC: (Ubuntu 9.2.1-9ubuntu2) 9.2.1 20191008
crypto   false
endian   little
havecode true
intrp    /lib64/ld-linux-x86-64.so.2
laddr    0x0
lang     c
linenum  true
lsyms    true
machine  AMD x86-64 architecture
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      true
relocs   true
relro    full
rpath    NONE
sanitiz  false
static   false
stripped false
subsys   linux
va       true
</code></pre>
<p>It&rsquo;s ELF64, I can run it locally too. Let&rsquo;s look into the functions.</p>
<pre><code class="language-radare2" data-lang="radare2">aflm
</code></pre><pre><code>entry0:
    reloc.__libc_start_main

entry.fini0:
    sym..plt.got
    rip

sym.remove_newline:
    sym.imp.strlen

sym.check_2:
    sym.imp.strlen
    sym.imp.malloc
    sym.imp.strcmp

sym.__libc_csu_init:
    sym._init
    rax

sym.check_1:
    sym.imp.strcmp

main:
    sym.imp.setvbuf
    sym.check
    sym.print_flag
    sym.imp.puts

sym.check:
    sym.imp.puts
    sym.imp.fgets
    sym.remove_newline
    sym.check_1
    sym.check_2
    sym.check_3
    sym.imp.__stack_chk_fail

sym.check_3:
    sym.imp.strlen
    sym.imp.malloc
    sym.imp.__stack_chk_fail

sym.print_flag:
    sym.imp.fopen
    sym.imp.puts
    sym.imp.exit
    sym.imp.fgets
    sym.imp.printf
    sym.imp.__stack_chk_fail
</code></pre>
<p>so we have <code>check</code> function called by <code>main</code> and inside it there are 3 functions <code>check_1</code>, <code>check_2</code> and <code>check_3</code></p>
<pre><code class="language-radare2" data-lang="radare2">s main
pdg
</code></pre><pre><code>bool main(undefined8 argc, char **argv)
{
    int32_t iVar1;
    undefined8 in_R8;
    undefined8 in_R9;
    char **var_10h;
    int64_t var_4h;
    
    sym.imp.setvbuf(_reloc.stdout, 0, 2, 0, in_R8, in_R9, argv);
    iVar1 = sym.check();
    if (iVar1 == 0) {
        sym.imp.puts(&quot;That\'s not it!&quot;);
    } else {
        sym.print_flag();
    }
    return iVar1 == 0;
}
</code></pre>
<p>Decompiling <code>main</code> using <a href="https://github.com/radareorg/r2ghidra-dec">r2ghidra-dec</a>!</p>
<p>So, <code>check</code> returns a boolean and if it&rsquo;s true we will get the flag.</p>
<pre><code class="language-radare2" data-lang="radare2">s sym.check
pdg
</code></pre><pre><code>undefined8 sym.check(void)
{
    int64_t iVar1;
    int32_t iVar2;
    undefined8 uVar3;
    int64_t in_FS_OFFSET;
    int64_t var_2018h;
    int64_t var_2010h;
    int64_t var_8h;
    
    iVar1 = *(int64_t *)(in_FS_OFFSET + 0x28);
    sym.imp.puts(&quot;Give me a key!&quot;);
    sym.imp.fgets(&amp;var_2010h, 0x2000, _reloc.stdin);
    sym.remove_newline((char *)&amp;var_2010h);
    iVar2 = sym.check_1((char *)&amp;var_2010h);
    if (iVar2 != 0) {
        sym.imp.puts(&quot;You have passed the first test! Now I need another key!&quot;);
        sym.imp.fgets(&amp;var_2010h, 0x2000, _reloc.stdin);
        sym.remove_newline((char *)&amp;var_2010h);
        iVar2 = sym.check_2((char *)&amp;var_2010h);
        if (iVar2 != 0) {
            sym.imp.puts(&quot;Nice work! You\'ve passes the second test, we aren\'t done yet!&quot;);
            sym.imp.fgets(&amp;var_2010h, 0x2000, _reloc.stdin);
            sym.remove_newline((char *)&amp;var_2010h);
            iVar2 = sym.check_3((char *)&amp;var_2010h);
            if (iVar2 != 0) {
                sym.imp.puts(&quot;Congrats you finished! Here is your flag!&quot;);
                uVar3 = 1;
                goto code_r0x00001450;
            }
        }
    }
    uVar3 = 0;
code_r0x00001450:
    if (iVar1 != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        sym.imp.__stack_chk_fail();
    }
    return uVar3;
}
</code></pre>
<p>There you have, your cascading <code>if</code> statements. Seems we need to dig deeper.</p>
<h3 id="solving-check_1">solving <code>check_1</code></h3>
<pre><code class="language-radare2" data-lang="radare2">s sym.check_1
pdg
</code></pre><pre><code>undefined8 sym.check_1(char *arg1)
{
    int32_t iVar1;
    undefined8 uVar2;
    char *s1;
    char *s2;
    char *var_8h;
    
    iVar1 = sym.imp.strcmp(arg1, &quot;starwars&quot;, &quot;starwars&quot;);
    if (iVar1 == 0) {
        iVar1 = sym.imp.strcmp(arg1, &quot;startrek&quot;, &quot;startrek&quot;);
        if (iVar1 == 0) {
            uVar2 = 0;
        } else {
            uVar2 = 1;
        }
    } else {
        uVar2 = 0;
    }
    return uVar2;
}
</code></pre>
<p>Alright, <code>check_1</code> is simple, it compares input with <code>starwars</code>, if it isn&rsquo;t equal then
it checks compares input with <code>startrek</code>. Hence, first input is either <code>starwars</code> or <code>startrek</code>.</p>
<p>Moving to <code>check_2</code></p>
<h3 id="solving-check_2">solving <code>check_2</code></h3>
<pre><code class="language-radare2" data-lang="radare2">s sym.check_2
pdg
</code></pre><pre><code>bool sym.check_2(char *arg1)
{
    int32_t iVar1;
    int64_t iVar2;
    char *s2;
    int32_t var_18h;
    char *var_10h;
    char *s1;
    
    iVar1 = sym.imp.strlen(arg1);
    iVar2 = sym.imp.malloc((int64_t)(iVar1 + 1) &lt;&lt; 3);
    var_18h = 0;
    while (var_18h &lt; iVar1) {
        *(char *)(iVar2 + var_18h) = &quot;si siht egassem terces&quot;[(iVar1 + -1) - var_18h];
        var_18h = var_18h + 1;
    }
    iVar1 = sym.imp.strcmp(iVar2, arg1, arg1);
    return iVar1 == 0;
}
</code></pre>
<p>Okay, <code>check_2</code> has a string <code>si siht egassem terces</code> which when read in reverse is <code>secret message this is</code>.
And the while loop is doing exactly that, reversing the string and comparing it with the second input.</p>
<p>Hence, our second input should be <code>secret message this is</code>.</p>
<p>Moving on to <code>check_3</code></p>
<h3 id="solving-check_3">solving <code>check_3</code></h3>
<pre><code class="language-radare2" data-lang="radare2">s sym.check_3
pdg
</code></pre><pre><code>bool sym.check_3(char *arg1)
{
    int64_t iVar1;
    bool bVar2;
    int64_t iVar3;
    uint64_t uVar4;
    int64_t in_FS_OFFSET;
    int64_t var_68h;
    int64_t var_54h;
    int32_t var_4ch;
    int64_t var_48h;
    int64_t var_40h;
    int64_t var_18h;
    
    iVar1 = *(int64_t *)(in_FS_OFFSET + 0x28);
    var_40h._0_4_ = 0x7a;
    var_40h._4_4_ = 0x21;
    iVar3 = sym.imp.strlen(arg1);
    iVar3 = sym.imp.malloc(iVar3 &lt;&lt; 2);
    var_54h._0_4_ = 0;
    while (uVar4 = sym.imp.strlen(arg1), (uint64_t)(int64_t)(int32_t)var_54h &lt; uVar4) {
        *(uint32_t *)(iVar3 + (int64_t)(int32_t)var_54h * 4) = (int32_t)arg1[(int32_t)var_54h] + 2U ^ 0x14;
        var_54h._0_4_ = (int32_t)var_54h + 1;
    }
    bVar2 = false;
    var_4ch = 0;
    while (uVar4 = sym.imp.strlen(arg1), (uint64_t)(int64_t)var_4ch &lt; uVar4) {
        if (*(int32_t *)(iVar3 + (int64_t)var_4ch * 4) != *(int32_t *)((int64_t)&amp;var_40h + (int64_t)var_4ch * 4)) {
            bVar2 = true;
        }
        var_4ch = var_4ch + 1;
    }
    if (iVar1 != *(int64_t *)(in_FS_OFFSET + 0x28)) {
    // WARNING: Subroutine does not return
        sym.imp.__stack_chk_fail();
    }
    return !bVar2;
}
</code></pre>
<p>This was rather interesting, I took me a while to understand while to understand what&rsquo;s going on in here. There is a bitwise XOR operation to a string 4 times the given input length (the malloc has the length of string left shift by 2).</p>
<p>This was until I found another solution, this was unintentional I suppose, judging by path we followed on reversing other 2 functions. The creator wants us to reverse this. But let&rsquo;s stick to the unintented solution.</p>
<p>Note the variable <code>bVar2</code>, initially it&rsquo;s set to <code>false</code>. And at the return of the function, it is <code>!bVar2</code> which means in order for the function return <code>true</code>, <code>bVar2</code> should be <code>false</code> which it is initially. The intention of the second <code>while</code> is to compared the input with the crated string and it turns <code>bVar2</code> to true whenever the comparison is <code>false</code>. This is a trivial technique, find if 2 strings are equal? Match it character by character and declare it equal only if you didn&rsquo;t find any mismatch till the end.</p>
<p>This is where I guess out unintended solution summons. The <code>while</code> loop runs as long as <code>var_4ch &lt; strlen(arg1)</code> where <code>arg1</code> is the input. If the loop never ran we wouldn&rsquo;t change out <code>bVar2</code>.</p>
<p>How to do that? <em>Supply an empty string</em> 🕶</p>
<p>The condition turns <code>false</code> in the first iteration itself and the <code>while</code> loop is never executed.</p>
<h3 id="the-result">The result</h3>
<p>So here is the solution, <code>nc</code> the challenge, then supply these inputs in order.</p>
<ol>
<li><code>starwars</code></li>
<li><code>secret message this is</code></li>
<li>`` (just hit enter)</li>
</ol>
<p>You will get the flag.</p>

</main>
    <footer>
  <hr/>
</footer>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-162174989-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  </body>
</html>
