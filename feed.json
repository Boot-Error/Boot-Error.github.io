{
  "version": "https://jsonfeed.org/version/1",
  "title": "Personal Blog of Vighnesh SK",
  "home_page_url": "https://boot-error.github.io/",
  "feed_url": "https://boot-error.github.io/feed.json",
  "description": "string providing more detail about feed",
  "user_comment": "purpose of the feed",
  "icon": "https://boot-error.github.io/img/me_outline.png",
  "author": {
    "name": "Vighnesh SK",
    "url": "https://boot-error.github.io",
    "avatar": "https://boot-error.github.io/img/me_outline.png"
  },
  "items": [
    {
      "id": "https://boot-error.github.io/post/vault-writeup/",
      "url": "https://boot-error.github.io/post/vault-writeup/",
      "title": "TAMUctf writeup - vault",
      "content_html": "<p class=\"markdown\">For me its been a long while since I challenged in a ctf competition. So I decided to play one because we in &quot;Quarantine&quot; anyway. This challenge is from <a href=\"https://tamuctf.com/challenges#VAULT\" class=\"markdown\">TAMUctf 2020</a> under &quot;Reversing&quot; named as 'vault'.</p> <p class=\"markdown\">I swear anything that says <code>vault</code> as a introductory challenge is a good way to brush up your basic debugging skills, because its the <code>printf(&quot;hello, world&quot;);</code> of reverse engineering and binary analysis.</p> <p class=\"markdown\">I'll be using <code>radare2</code> using <code>jupyter-radare2</code> kernel.</p> <h3 id=\"recon\" class=\"markdown\">Recon <a class=\"header-anchor markdown\" href=\"#recon\">↩</a></h3> <p class=\"markdown\">First let's analyze the binary.</p> <pre><code>o vault aaa </code></pre> <pre><code>i </code></pre> <pre><code>fd       4 file     vault size     0x4230 humansz  16.5K mode     r-x format   elf64 iorw     false blksz    0x0 block    0x100 type     DYN (Shared object file) arch     x86 baddr    0x0 binsz    15020 bintype  elf bits     64 canary   false class    ELF64 compiler GCC: (Debian 9.3.0-3) 9.3.0 crypto   false endian   little havecode true intrp    /lib64/ld-linux-x86-64.so.2 laddr    0x0 lang     c linenum  true lsyms    true machine  AMD x86-64 architecture maxopsz  16 minopsz  1 nx       true os       linux pcalign  0 pic      true relocs   true relro    partial rpath    NONE sanitiz  false static   false stripped false subsys   linux va       true </code></pre> <p class=\"markdown\">It's ELF 64 and not <code>stripped</code>. Awww yea!</p> <h3 id=\"function-calls\" class=\"markdown\">Function calls <a class=\"header-anchor markdown\" href=\"#function-calls\">↩</a></h3> <p class=\"markdown\">Analyzing the function call stack, it's evident that it takes input from user using <code>fgets</code> and displays results.</p> <pre><code>aflm </code></pre> <pre><code>entry0:     reloc.__libc_start_main  entry.fini0:     sym..plt.got     rip  sym.deobfuscate:     sym.imp.strlen  sym.__libc_csu_init:     sym._init     rsi  main:     sym.imp.malloc     sym.deobfuscate     sym.imp.printf     sym.imp.fgets     sym.imp.strcmp     sym.imp.puts </code></pre> <p class=\"markdown\">And <code>deobfuscate</code> is a defined function. Might be something related to password?</p> <h3 id=\"analyze-main\" class=\"markdown\">Analyze <code>main</code> <a class=\"header-anchor markdown\" href=\"#analyze-main\">↩</a></h3> <pre><code>s main pdf </code></pre> <pre><code>┌ 207: int main (int argc, char **argv, char **envp); │           ; var char *s2 @ rbp-0x10 │           ; var char *s1 @ rbp-0x8 │           ; DATA XREF from entry0 @ 0x10bd │           0x000012c9      55             push rbp │           0x000012ca      4889e5         mov rbp, rsp │           0x000012cd      4883ec10       sub rsp, 0x10 │           0x000012d1      bf1a000000     mov edi, 0x1a               ; size_t size │           0x000012d6      e8a5fdffff     call sym.imp.malloc         ;  void *malloc(size_t size) │           0x000012db      488945f8       mov qword [s1], rax │           0x000012df      488b45f8       mov rax, qword [s1] │           0x000012e3      48be34343238.  movabs rsi, 0x7e394c2f38323434 ; '4428/L9~' │           0x000012ed      48bf783a787b.  movabs rdi, 0x54834c1f7b783a78 │           0x000012f7      488930         mov qword [rax], rsi │           0x000012fa      48897808       mov qword [rax + 8], rdi │           0x000012fe      48b928298484.  movabs rcx, 0x2f72857884842928 │           0x00001308      48894810       mov qword [rax + 0x10], rcx │           0x0000130c      66c740186776   mov word [rax + 0x18], 0x7667 ; 'gv' │                                                                      ; [0x7667:2]=0xffff │           0x00001312      c6401a00       mov byte [rax + 0x1a], 0 │           0x00001316      488b45f8       mov rax, qword [s1] │           0x0000131a      4889c7         mov rdi, rax │           0x0000131d      e863feffff     call sym.deobfuscate │           0x00001322      bf1b000000     mov edi, 0x1b               ; size_t size │           0x00001327      e854fdffff     call sym.imp.malloc         ;  void *malloc(size_t size) │           0x0000132c      488945f0       mov qword [s2], rax │           0x00001330      488d35d10c00.  lea rsi, str.Enter_password: ; 0x2008 ; &quot;Enter password: &quot; │           0x00001337      488d3ddb0c00.  lea rdi, [0x00002019]       ; &quot;%s&quot; ; const char *format │           0x0000133e      b800000000     mov eax, 0 │           0x00001343      e808fdffff     call sym.imp.printf         ; int printf(const char *format) │           0x00001348      488b15112d00.  mov rdx, qword [obj.stdin]  ; obj.stdin__GLIBC_2.2.5 │                                                                      ; [0x4060:8]=0 ; FILE *stream │           0x0000134f      488b45f0       mov rax, qword [s2] │           0x00001353      be1b000000     mov esi, 0x1b               ; int size │           0x00001358      4889c7         mov rdi, rax                ; char *s │           0x0000135b      e800fdffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream) │           0x00001360      488b55f0       mov rdx, qword [s2] │           0x00001364      488b45f8       mov rax, qword [s1] │           0x00001368      4889d6         mov rsi, rdx                ; const char *s2 │           0x0000136b      4889c7         mov rdi, rax                ; const char *s1 │           0x0000136e      e8fdfcffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2) │           0x00001373      85c0           test eax, eax │       ┌─&lt; 0x00001375      750e           jne 0x1385 │       │   0x00001377      488d3da20c00.  lea rdi, str.Correct___That_s_the_password ; 0x2020 ; &quot;Correct!  That's the password!&quot; ; const char *s │       │   0x0000137e      e8adfcffff     call sym.imp.puts           ; int puts(const char *s) │      ┌──&lt; 0x00001383      eb0c           jmp 0x1391 │      ││   ; CODE XREF from main @ 0x1375 │      │└─&gt; 0x00001385      488d3db40c00.  lea rdi, str.Sorry__that_isn_t_the_right_password. ; 0x2040 ; &quot;Sorry, that isn't the right password.&quot; ; const char *s │      │    0x0000138c      e89ffcffff     call sym.imp.puts           ; int puts(const char *s) │      │    ; CODE XREF from main @ 0x1383 │      └──&gt; 0x00001391      b800000000     mov eax, 0 │           0x00001396      c9             leave └           0x00001397      c3             ret </code></pre> <p class=\"markdown\">Seems pretty trivial, the <code>deobfuscate</code> functions makes some sort of string and stores in <code>s1</code>, then the program asks user to &quot;Enter Password&quot;, the input is taken and is of the size <code>0x1b</code> and stored in <code>s2</code>. Note that <code>fgets</code> is used. The creator doesn't want us to buffer overflow.</p> <p class=\"markdown\">And then the two strings are compared, if they are equal it stays &quot;That's the password and exits&quot; ?!?</p> <p class=\"markdown\">At this stage, I'm pretty sure the string in <code>s1</code> created from <code>deobfuscate</code> is the flag we need.</p> <p class=\"markdown\">Let's check the disassembly of <code>deobfuscate</code></p> <pre><code>s sym.deobfuscate pdf </code></pre> <pre><code>┌ 324: sym.deobfuscate (char *arg1); │           ; var char *s @ rbp-0x28 │           ; var int64_t var_15h @ rbp-0x15 │           ; var size_t var_14h @ rbp-0x14 │           ; var size_t var_10h @ rbp-0x10 │           ; var int64_t var_ch @ rbp-0xc │           ; var int64_t var_8h @ rbp-0x8 │           ; var int64_t var_4h @ rbp-0x4 │           ; arg char *arg1 @ rdi │           ; CALL XREF from main @ 0x131d │           0x00001185      55             push rbp │           0x00001186      4889e5         mov rbp, rsp │           0x00001189      4883ec30       sub rsp, 0x30 │           0x0000118d      48897dd8       mov qword [s], rdi          ; arg1 │           0x00001191      488b45d8       mov rax, qword [s] │           0x00001195      4889c7         mov rdi, rax                ; const char *s │           0x00001198      e8a3feffff     call sym.imp.strlen         ; size_t strlen(const char *s) │           0x0000119d      8945ec         mov dword [var_14h], eax │           0x000011a0      c745fc000000.  mov dword [var_4h], 0 │       ┌─&lt; 0x000011a7      eb4f           jmp 0x11f8 │       │   ; CODE XREF from sym.deobfuscate @ 0x11fe │      ┌──&gt; 0x000011a9      8b45fc         mov eax, dword [var_4h] │      ╎│   0x000011ac      4863d0         movsxd rdx, eax │      ╎│   0x000011af      488b45d8       mov rax, qword [s] │      ╎│   0x00001296      4863d0         movsxd rdx, eax  . . . . . . .  i t s  h u g e  a n d  w o r t h l e s s  t o  w o r r y  a b o u t    . . . . . . .  │      ╎│   0x00001299      488b45d8       mov rax, qword [s] │      ╎│   0x0000129d      4801d0         add rax, rdx │      ╎│   0x000012a0      0fb608         movzx ecx, byte [rax] │      ╎│   0x000012a3      8b45f0         mov eax, dword [var_10h] │      ╎│   0x000012a6      4898           cdqe │      ╎│   0x000012a8      488d50ff       lea rdx, [rax - 1] │      ╎│   0x000012ac      488b45d8       mov rax, qword [s] │      ╎│   0x000012b0      4801d0         add rax, rdx │      ╎│   0x000012b3      31ce           xor esi, ecx │      ╎│   0x000012b5      89f2           mov edx, esi │      ╎│   0x000012b7      8810           mov byte [rax], dl │      ╎│   0x000012b9      836df001       sub dword [var_10h], 1 │      ╎│   ; CODE XREF from sym.deobfuscate @ 0x1278 │      ╎└─&gt; 0x000012bd      837df000       cmp dword [var_10h], 0 │      └──&lt; 0x000012c1      7fb7           jg 0x127a │           0x000012c3      488b45d8       mov rax, qword [s] │           0x000012c7      c9             leave └           0x000012c8      c3             ret </code></pre> <p class=\"markdown\">It's huge, and I'm too lazy to do it. So here is the thing, the function only takes an memory address to strcpy the computed password and it doesn't require any parameter that changes i.e it's a <a href=\"https://en.wikipedia.org/wiki/Pure_function\" class=\"markdown\">pure</a> functions? I'm looking at you, fp nerds.</p> <p class=\"markdown\">Why don't we just debug it.</p> <h3 id=\"debugging-to-get-the-flag\" class=\"markdown\">Debugging to get the flag <a class=\"header-anchor markdown\" href=\"#debugging-to-get-the-flag\">↩</a></h3> <pre><code>ood </code></pre> <pre><code>73743 </code></pre> <pre><code>dcu main pd </code></pre> <pre><code>┌ 207: int main (int argc, char **argv, char **envp); │           ; var char *s2 @ rbp-0x10 │           ; var char *s1 @ rbp-0x8 │           ; DATA XREF from entry0 @ 0x559ab2a2d0bd │           0x559ab2a2d2c9      55             push rbp │           0x559ab2a2d2ca      4889e5         mov rbp, rsp │           0x559ab2a2d2cd      4883ec10       sub rsp, 0x10 │           0x559ab2a2d2d1      bf1a000000     mov edi, 0x1a           ; 26 ; size_t size │           0x559ab2a2d2d6      e8a5fdffff     call sym.imp.malloc     ;  void *malloc(size_t size) │           0x559ab2a2d2db      488945f8       mov qword [s1], rax │           0x559ab2a2d2df      488b45f8       mov rax, qword [s1] │           0x559ab2a2d2e3      48be34343238.  movabs rsi, 0x7e394c2f38323434 ; '4428/L9~' │           0x559ab2a2d2ed      48bf783a787b.  movabs rdi, 0x54834c1f7b783a78 │           0x559ab2a2d2f7      488930         mov qword [rax], rsi │           0x559ab2a2d2fa      48897808       mov qword [rax + 8], rdi │           0x559ab2a2d2fe      48b928298484.  movabs rcx, 0x2f72857884842928 │           0x559ab2a2d308      48894810       mov qword [rax + 0x10], rcx │           0x559ab2a2d30c      66c740186776   mov word [rax + 0x18], 0x7667 ; 'gv' │                                                                      ; [0x7667:2]=0xffff │           0x559ab2a2d312      c6401a00       mov byte [rax + 0x1a], 0 │           0x559ab2a2d316      488b45f8       mov rax, qword [s1] │           0x559ab2a2d31a      4889c7         mov rdi, rax │           0x559ab2a2d31d      e863feffff     call sym.deobfuscate │           0x559ab2a2d322      bf1b000000     mov edi, 0x1b           ; 27 ; size_t size │           0x559ab2a2d327      e854fdffff     call sym.imp.malloc     ;  void *malloc(size_t size) │           0x559ab2a2d32c      488945f0       mov qword [s2], rax │           0x559ab2a2d330      488d35d10c00.  lea rsi, str.Enter_password: ; 0x559ab2a2e008 ; &quot;Enter password: &quot; │           0x559ab2a2d337      488d3ddb0c00.  lea rdi, [0x559ab2a2e019] ; &quot;%s&quot; ; const char *format │           0x559ab2a2d33e      b800000000     mov eax, 0 │           0x559ab2a2d343      e808fdffff     call sym.imp.printf     ; int printf(const char *format) │           0x559ab2a2d348      488b15112d00.  mov rdx, qword [obj.stdin] ; obj.stdin__GLIBC_2.2.5 │                                                                      ; [0x559ab2a30060:8]=0x7f9f4702c7e0 ; FILE *stream │           0x559ab2a2d34f      488b45f0       mov rax, qword [s2] │           0x559ab2a2d353      be1b000000     mov esi, 0x1b           ; 27 ; int size │           0x559ab2a2d358      4889c7         mov rdi, rax            ; char *s │           0x559ab2a2d35b      e800fdffff     call sym.imp.fgets      ; char *fgets(char *s, int size, FILE *stream) │           0x559ab2a2d360      488b55f0       mov rdx, qword [s2] │           0x559ab2a2d364      488b45f8       mov rax, qword [s1] │           0x559ab2a2d368      4889d6         mov rsi, rdx            ; const char *s2 │           0x559ab2a2d36b      4889c7         mov rdi, rax            ; const char *s1 │           0x559ab2a2d36e      e8fdfcffff     call sym.imp.strcmp     ; int strcmp(const char *s1, const char *s2) │           0x559ab2a2d373      85c0           test eax, eax │           0x559ab2a2d375      750e           jne 0x559ab2a2d385 │           0x559ab2a2d377      488d3da20c00.  lea rdi, str.Correct___That_s_the_password ; 0x559ab2a2e020 ; &quot;Correct!  That's the password!&quot; ; const char *s │           0x559ab2a2d37e      e8adfcffff     call sym.imp.puts       ; int puts(const char *s) │           0x559ab2a2d383      eb0c           jmp 0x559ab2a2d391 │           ; CODE XREF from main @ 0x559ab2a2d375 │           0x559ab2a2d385      488d3db40c00.  lea rdi, str.Sorry__that_isn_t_the_right_password. ; 0x559ab2a2e040 ; &quot;Sorry, that isn't the right password.&quot; ; const char *s │           0x559ab2a2d38c      e89ffcffff     call sym.imp.puts       ; int puts(const char *s) │           ; CODE XREF from main @ 0x559ab2a2d383 │           0x559ab2a2d391      b800000000     mov eax, 0 │           0x559ab2a2d396      c9             leave └           0x559ab2a2d397      c3             ret </code></pre> <p class=\"markdown\">Now the program is memory as a process. We have it hit a brekpoint at beginning of <code>main</code> to see the locations in memory of the program. The <code>deobfuscation</code> is called at address <code>0x559ab2a2d31d</code>. We now set a breakpoint at the next instruction <code>0x559ab2a2d322</code>.</p> <pre><code>dcu 0x559ab2a2d322 </code></pre> <p class=\"markdown\">Since we have hit the breakpoint, let's capture what all happened. The function is called and it has filled the location <code>s1</code> in memory with a string which is compared later on with the user input. Note that the <code>s1</code> address is stored in register <code>rdi</code>. Hence now the string created by the function is in the memory address which <code>rdi</code> holds, check 3 instructions from <code>0x559ab2a2d316</code>.</p> <p class=\"markdown\">Examining strings at the memory location in <code>rdi</code></p> <pre><code>x/s @ rdi </code></pre> <pre><code>0x559ab37002a0 gigem{p455w0rd_1n_m3m0ry1} 0x559ab37002ba A 0x559ab37002cb </code></pre> <p class=\"markdown\">And there we have the flag! It says <em>password_in_memory</em> :laughing:</p> ",
      "date_published": "2020-03-29T00:00:00.000Z"
    },
    {
      "id": "https://boot-error.github.io/post/lvm/",
      "url": "https://boot-error.github.io/post/lvm/",
      "title": "Adopting LVM",
      "content_html": "<p class=\"markdown\">I use Arch Linux on every machine in my possession.</p> <p class=\"markdown\">Within a year of its use, I realized what Arch Linux F**kups really mean and why people cry about it.</p> <p class=\"markdown\">But I figured out a escape to a problem I always faced during a f**kup, It's the disk partitions and re-installation.</p> <!-- more --> <h2 id=\"the-trouble\" class=\"markdown\">The Trouble <a class=\"header-anchor markdown\" href=\"#the-trouble\">↩</a></h2> <p class=\"markdown\">Traditionally you would have a setup like this.</p> <pre><code>n00b:  - /dev/sda1 \t- / (OS installation) \t\t- /home/user (home folder) </code></pre> <p class=\"markdown\">Your everyhing is in the root partition. Now if by some reason your <code>root</code> is screwed, you have to spend time backing up your <code>home</code> partition. And if you are a data hoader, you be spending time in backing it up to wipe clean the partition for fresh install.</p> <p class=\"markdown\">I have been with this setup before using Arch Linux but Ubuntu didn't screw itself up that often.</p> <pre><code>intermediate:  - /dev/sda1 \t- / (OS installation) - /dev/sda2 \t- /home/use (home folder) </code></pre> <p class=\"markdown\">Now here are utilizing disk partitioning for <code>home</code> and <code>root</code> partitions.</p> <p class=\"markdown\">Why? because organization. But most importantly, there is separation b/w them. There is no need to worry about first case anymore. Just wipe <code>root</code> and install again, you'll be up with fresh install with all your files not even touched.</p> <p class=\"markdown\">This was me for a whole again. It worked flawlessly, took be 1-2 days to get back on track with packages and necessary software.</p> <h2 id=\"getting-better-at-the-game\" class=\"markdown\">Getting better at the game <a class=\"header-anchor markdown\" href=\"#getting-better-at-the-game\">↩</a></h2> <p class=\"markdown\">The f**kups got better since then, some of them were</p> <ul class=\"markdown\"> <li class=\"markdown\">A update got interrupted due to network failure, didn't verify the packages and it failed to install a critical library <code>i18n</code>, which was a dependency to many software including <code>pacman</code>. I figured out since it was installtion problem, might well re-install it. But <code>pacman</code> depended on this. I somehow fixed it by manually installing this libary, had to do some symlinks.</li> <li class=\"markdown\">Some startup service didn't start and the system refused to give me a shell. which required me a re-install.</li> </ul> <p class=\"markdown\">The quest to tweak my Arch Linux to perfection was always on. This led me to <code>lvm</code>, it all sounded fancy because of it capabilities like <code>Logical Paritions</code> and its dynamic abilities.</p> <h2 id=\"adopting-lvm\" class=\"markdown\">Adopting LVM <a class=\"header-anchor markdown\" href=\"#adopting-lvm\">↩</a></h2> <p class=\"markdown\">I found out about LVM while browsing list of applications in ArchWiki. It was the moment it struck that this is the setup I have been in grave need. A solution to a minor inconvinience.</p> <p class=\"markdown\">One particular feature which I love about LVM is</p> <p class=\"markdown\">That's right, running out of space because you use too many docker images? Expand your <code>root</code> on the fly without worrying about making up space adjacent to it. This also means I can have multiple distros saved in rather small partitons because it can resized whenever required.</p> <p class=\"markdown\">Learn more about it</p> <ul class=\"markdown\"> <li class=\"markdown\"><a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-lvm-concepts-terminology-and-operations\" class=\"markdown\">An Introduction to LVM</a></li> <li class=\"markdown\"><a href=\"https://wiki.archlinux.org/index.php/LVM\" class=\"markdown\">LVM - ArchWiki</a></li> </ul> <h2 id=\"my-setup\" class=\"markdown\">My Setup <a class=\"header-anchor markdown\" href=\"#my-setup\">↩</a></h2> <p class=\"markdown\">My setup to LVM is really simple. The only reason to choose this setup to have flexibility on managing partition without a headache, which means it takes some effort to set them up.</p> <h3 id=\"physical-volume-setup\" class=\"markdown\">Physical Volume Setup <a class=\"header-anchor markdown\" href=\"#physical-volume-setup\">↩</a></h3> <p class=\"markdown\">I have single 256GB SSD in my thinkpad x1c which I have split into 2 physical partitions <code>/dev/sda2</code> and <code>/dev/sda3</code>, <code>/dev/sda1</code> is the boot partition.</p> <p class=\"markdown\">These partitions are configured to be our physical partitions. One explicitly for <code>distros</code> and other for <code>datadir</code> which will be <code>home</code> partitions.</p> <pre><code>$ sudo pvs   PV         VG      Fmt  Attr PSize    PFree   /dev/sda2  distros lvm2 a--  &lt;118.71g &lt;68.71g   /dev/sda3  datadir lvm2 a--   119.26g  49.26g </code></pre> <p class=\"markdown\">If you own a system with hybrid disk setup, one being SSD usually 128GB and HDD of 1TB, the physical volumes can be set to use <code>root</code> to be loaded from SSD and <code>home</code> from HDD. Or want to be a master of optimization crafts, use parts of <code>root</code> and <code>home</code> in your SSD to speed up boot time and load the rest like <code>Music</code> from HDD.</p> <p class=\"markdown\">Such an ambition would be a mess to implement, but LVM makes it painless.</p> <h3 id=\"volume-groups-setup\" class=\"markdown\">Volume Groups Setup <a class=\"header-anchor markdown\" href=\"#volume-groups-setup\">↩</a></h3> <p class=\"markdown\">Volume groups are collection of physical volumes, you can collate multiple physical volumes into a single group. I choose to mirror my physical volumes as volume groups</p> <pre><code>$ sudo vgs   VG      #PV #LV #SN Attr   VSize    VFree   datadir   1   1   0 wz--n-  119.26g  49.26g   distros   1   1   0 wz--n- &lt;118.71g &lt;68.71g </code></pre> <p class=\"markdown\">Volume groups gives you an abstract over your physical volumes, the <em>logical volumes</em> created are categorized into these volumes.</p> <h3 id=\"logical-volumes\" class=\"markdown\">Logical Volumes <a class=\"header-anchor markdown\" href=\"#logical-volumes\">↩</a></h3> <p class=\"markdown\">This is the abstraction I seek to implement. On my X1C, this is the setup</p> <pre><code>$ sudo lvs   LV                   VG      Attr       LSize   booterror-home-crypt datadir -wi-ao---- 70.00g   arch-main            distros -wi-ao---- 50.00g </code></pre> <p class=\"markdown\"><code>arch-main</code> is my current Arch Linux installation and <code>booterror-home-crypt</code> is the root partition for user <code>booterror</code> which is a <code>LUKS</code> encrypted partition. And Yes keep your personal data encrypted, will save you from intrusion by physical access like a theft :laughing:</p> <p class=\"markdown\">Note that the size of the partitions, I can use rest of free space in volume groups to make new partitions for different distros and respective users.</p> <h3 id=\"final-structure\" class=\"markdown\">Final structure <a class=\"header-anchor markdown\" href=\"#final-structure\">↩</a></h3> <p class=\"markdown\">Here is my final disk structure with all the necessary complexities added just so I can <em>resize on the fly</em></p> <pre><code>$ lsblk NAME                               MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINT sda                                  8:0    0 238.5G  0 disk ├─sda1                               8:1    0   511M  0 part  /boot ├─sda2                               8:2    0 118.7G  0 part │ └─distros-arch--main             254:0    0    50G  0 lvm   / └─sda3                               8:3    0 119.3G  0 part   └─datadir-booterror--home--crypt 254:1    0    70G  0 lvm \t└─booterror-home               254:2    0    70G  0 crypt </code></pre> <h2 id=\"there's-more\" class=\"markdown\">There's more <a class=\"header-anchor markdown\" href=\"#there's-more\">↩</a></h2> <p class=\"markdown\">I figured out LVM can do <a href=\"https://wiki.archlinux.org/index.php/LVM#Snapshots\" class=\"markdown\">snapshotting</a>, essentially a time machine for your partitions. One useful setup would be to have a snapshot of your bare minimum arch linux installation as a snapshot, whenever there is a f**kup and its beyond fix, just revert to this snapshot. You can keep a list of all packages you need to install in a txt file and run pacman right away after reverting to this bare minimum state.</p> <p class=\"markdown\">A snapshot setup would be more rewarding than a abstract just so I can resize on the fly.</p> <p class=\"markdown\">I need to experiment this setup, until then...</p> ",
      "date_published": "2020-03-30T00:00:00.000Z"
    },
    {
      "id": "https://boot-error.github.io/post/cracker_barrel_writeup/",
      "url": "https://boot-error.github.io/post/cracker_barrel_writeup/",
      "title": "AUCTF writeup - cracker_barrel",
      "content_html": "<p class=\"markdown\">In <a href=\"https://ctf.auburn.edu/\" class=\"markdown\">AUCTF 2020</a> under <code>rev</code> section, the challenge <a href=\"https://github.com/auehc/AUCTF-2020/blob/master/Reversing/Cracker%20Barrel/prompt.md\" class=\"markdown\">cracker barrel</a> had a binary given running on remote.</p> <p class=\"markdown\">Let's rev it up.</p> <h3 id=\"recon\" class=\"markdown\">recon <a class=\"header-anchor markdown\" href=\"#recon\">↩</a></h3> <pre><code>o cracker_barrel aaa i </code></pre> <pre><code>fd       6 file     cracker_barrel size     0x43e8 humansz  17.0K mode     r-x format   elf64 iorw     false blksz    0x0 block    0x100 type     DYN (Shared object file) arch     x86 baddr    0x0 binsz    15399 bintype  elf bits     64 canary   true class    ELF64 compiler GCC: (Ubuntu 9.2.1-9ubuntu2) 9.2.1 20191008 crypto   false endian   little havecode true intrp    /lib64/ld-linux-x86-64.so.2 laddr    0x0 lang     c linenum  true lsyms    true machine  AMD x86-64 architecture maxopsz  16 minopsz  1 nx       true os       linux pcalign  0 pic      true relocs   true relro    full rpath    NONE sanitiz  false static   false stripped false subsys   linux va       true </code></pre> <p class=\"markdown\">It's ELF64, I can run it locally too. Let's look into the functions.</p> <pre><code>aflm </code></pre> <pre><code>entry0:     reloc.__libc_start_main  entry.fini0:     sym..plt.got     rip  sym.remove_newline:     sym.imp.strlen  sym.check_2:     sym.imp.strlen     sym.imp.malloc     sym.imp.strcmp  sym.__libc_csu_init:     sym._init     rax  sym.check_1:     sym.imp.strcmp  main:     sym.imp.setvbuf     sym.check     sym.print_flag     sym.imp.puts  sym.check:     sym.imp.puts     sym.imp.fgets     sym.remove_newline     sym.check_1     sym.check_2     sym.check_3     sym.imp.__stack_chk_fail  sym.check_3:     sym.imp.strlen     sym.imp.malloc     sym.imp.__stack_chk_fail  sym.print_flag:     sym.imp.fopen     sym.imp.puts     sym.imp.exit     sym.imp.fgets     sym.imp.printf     sym.imp.__stack_chk_fail </code></pre> <p class=\"markdown\">so we have <code>check</code> function called by <code>main</code> and inside it there are 3 functions <code>check_1</code>, <code>check_2</code> and <code>check_3</code></p> <pre><code>s main pdg </code></pre> <pre><code>bool main(undefined8 argc, char **argv) {     int32_t iVar1;     undefined8 in_R8;     undefined8 in_R9;     char **var_10h;     int64_t var_4h;      sym.imp.setvbuf(_reloc.stdout, 0, 2, 0, in_R8, in_R9, argv);     iVar1 = sym.check();     if (iVar1 == 0) {         sym.imp.puts(&quot;That\\'s not it!&quot;);     } else {         sym.print_flag();     }     return iVar1 == 0; } </code></pre> <p class=\"markdown\">Decompiling <code>main</code> using <a href=\"https://github.com/radareorg/r2ghidra-dec\" class=\"markdown\">r2ghidra-dec</a>!</p> <p class=\"markdown\">So, <code>check</code> returns a boolean and if it's true we will get the flag.</p> <pre><code>s sym.check pdg </code></pre> <pre><code>undefined8 sym.check(void) {     int64_t iVar1;     int32_t iVar2;     undefined8 uVar3;     int64_t in_FS_OFFSET;     int64_t var_2018h;     int64_t var_2010h;     int64_t var_8h;      iVar1 = *(int64_t *)(in_FS_OFFSET + 0x28);     sym.imp.puts(&quot;Give me a key!&quot;);     sym.imp.fgets(&amp;var_2010h, 0x2000, _reloc.stdin);     sym.remove_newline((char *)&amp;var_2010h);     iVar2 = sym.check_1((char *)&amp;var_2010h);     if (iVar2 != 0) {         sym.imp.puts(&quot;You have passed the first test! Now I need another key!&quot;);         sym.imp.fgets(&amp;var_2010h, 0x2000, _reloc.stdin);         sym.remove_newline((char *)&amp;var_2010h);         iVar2 = sym.check_2((char *)&amp;var_2010h);         if (iVar2 != 0) {             sym.imp.puts(&quot;Nice work! You\\'ve passes the second test, we aren\\'t done yet!&quot;);             sym.imp.fgets(&amp;var_2010h, 0x2000, _reloc.stdin);             sym.remove_newline((char *)&amp;var_2010h);             iVar2 = sym.check_3((char *)&amp;var_2010h);             if (iVar2 != 0) {                 sym.imp.puts(&quot;Congrats you finished! Here is your flag!&quot;);                 uVar3 = 1;                 goto code_r0x00001450;             }         }     }     uVar3 = 0; code_r0x00001450:     if (iVar1 != *(int64_t *)(in_FS_OFFSET + 0x28)) {     // WARNING: Subroutine does not return         sym.imp.__stack_chk_fail();     }     return uVar3; } </code></pre> <p class=\"markdown\">There you have, your cascading <code>if</code> statements. Seems we need to dig deeper.</p> <h3 id=\"solving-check_1\" class=\"markdown\">solving <code>check_1</code> <a class=\"header-anchor markdown\" href=\"#solving-check_1\">↩</a></h3> <pre><code>s sym.check_1 pdg </code></pre> <pre><code>undefined8 sym.check_1(char *arg1) {     int32_t iVar1;     undefined8 uVar2;     char *s1;     char *s2;     char *var_8h;      iVar1 = sym.imp.strcmp(arg1, &quot;starwars&quot;, &quot;starwars&quot;);     if (iVar1 == 0) {         iVar1 = sym.imp.strcmp(arg1, &quot;startrek&quot;, &quot;startrek&quot;);         if (iVar1 == 0) {             uVar2 = 0;         } else {             uVar2 = 1;         }     } else {         uVar2 = 0;     }     return uVar2; } </code></pre> <p class=\"markdown\">Alright, <code>check_1</code> is simple, it compares input with <code>starwars</code>, if it isn't equal then it checks compares input with <code>startrek</code>. Hence, first input is either <code>starwars</code> or <code>startrek</code>.</p> <p class=\"markdown\">Moving to <code>check_2</code></p> <h3 id=\"solving-check_2\" class=\"markdown\">solving <code>check_2</code> <a class=\"header-anchor markdown\" href=\"#solving-check_2\">↩</a></h3> <pre><code>s sym.check_2 pdg </code></pre> <pre><code>bool sym.check_2(char *arg1) {     int32_t iVar1;     int64_t iVar2;     char *s2;     int32_t var_18h;     char *var_10h;     char *s1;      iVar1 = sym.imp.strlen(arg1);     iVar2 = sym.imp.malloc((int64_t)(iVar1 + 1) &lt;&lt; 3);     var_18h = 0;     while (var_18h &lt; iVar1) {         *(char *)(iVar2 + var_18h) = &quot;si siht egassem terces&quot;[(iVar1 + -1) - var_18h];         var_18h = var_18h + 1;     }     iVar1 = sym.imp.strcmp(iVar2, arg1, arg1);     return iVar1 == 0; } </code></pre> <p class=\"markdown\">Okay, <code>check_2</code> has a string <code>si siht egassem terces</code> which when read in reverse is <code>secret message this is</code>. And the while loop is doing exactly that, reversing the string and comparing it with the second input.</p> <p class=\"markdown\">Hence, our second input should be <code>secret message this is</code>.</p> <p class=\"markdown\">Moving on to <code>check_3</code></p> <h3 id=\"solving-check_3\" class=\"markdown\">solving <code>check_3</code> <a class=\"header-anchor markdown\" href=\"#solving-check_3\">↩</a></h3> <pre><code>s sym.check_3 pdg </code></pre> <pre><code>bool sym.check_3(char *arg1) {     int64_t iVar1;     bool bVar2;     int64_t iVar3;     uint64_t uVar4;     int64_t in_FS_OFFSET;     int64_t var_68h;     int64_t var_54h;     int32_t var_4ch;     int64_t var_48h;     int64_t var_40h;     int64_t var_18h;      iVar1 = *(int64_t *)(in_FS_OFFSET + 0x28);     var_40h._0_4_ = 0x7a;     var_40h._4_4_ = 0x21;     iVar3 = sym.imp.strlen(arg1);     iVar3 = sym.imp.malloc(iVar3 &lt;&lt; 2);     var_54h._0_4_ = 0;     while (uVar4 = sym.imp.strlen(arg1), (uint64_t)(int64_t)(int32_t)var_54h &lt; uVar4) {         *(uint32_t *)(iVar3 + (int64_t)(int32_t)var_54h * 4) = (int32_t)arg1[(int32_t)var_54h] + 2U ^ 0x14;         var_54h._0_4_ = (int32_t)var_54h + 1;     }     bVar2 = false;     var_4ch = 0;     while (uVar4 = sym.imp.strlen(arg1), (uint64_t)(int64_t)var_4ch &lt; uVar4) {         if (*(int32_t *)(iVar3 + (int64_t)var_4ch * 4) != *(int32_t *)((int64_t)&amp;var_40h + (int64_t)var_4ch * 4)) {             bVar2 = true;         }         var_4ch = var_4ch + 1;     }     if (iVar1 != *(int64_t *)(in_FS_OFFSET + 0x28)) {     // WARNING: Subroutine does not return         sym.imp.__stack_chk_fail();     }     return !bVar2; } </code></pre> <p class=\"markdown\">This was rather interesting, I took me a while to understand while to understand what's going on in here. There is a bitwise XOR operation to a string 4 times the given input length (the malloc has the length of string left shift by 2).</p> <p class=\"markdown\">This was until I found another solution, this was unintentional I suppose, judging by path we followed on reversing other 2 functions. The creator wants us to reverse this. But let's stick to the unintented solution.</p> <p class=\"markdown\">Note the variable <code>bVar2</code>, initially it's set to <code>false</code>. And at the return of the function, it is <code>!bVar2</code> which means in order for the function return <code>true</code>, <code>bVar2</code> should be <code>false</code> which it is initially. The intention of the second <code>while</code> is to compared the input with the crated string and it turns <code>bVar2</code> to true whenever the comparison is <code>false</code>. This is a trivial technique, find if 2 strings are equal? Match it character by character and declare it equal only if you didn't find any mismatch till the end.</p> <p class=\"markdown\">This is where I guess out unintended solution summons. The <code>while</code> loop runs as long as <code>var_4ch &lt; strlen(arg1)</code> where <code>arg1</code> is the input. If the loop never ran we wouldn't change out <code>bVar2</code>.</p> <p class=\"markdown\">How to do that? <em>Supply an empty string</em> :sunglasses:</p> <p class=\"markdown\">The condition turns <code>false</code> in the first iteration itself and the <code>while</code> loop is never executed.</p> <h3 id=\"the-result\" class=\"markdown\">The result <a class=\"header-anchor markdown\" href=\"#the-result\">↩</a></h3> <p class=\"markdown\">So here is the solution, <code>nc</code> the challenge, then supply these inputs in order.</p> <ol class=\"markdown\"> <li class=\"markdown\"><code>starwars</code></li> <li class=\"markdown\"><code>secret message this is</code></li> <li class=\"markdown\">`` (just hit enter)</li> </ol> <p class=\"markdown\">You will get the flag.</p> ",
      "date_published": "2020-04-06T00:00:00.000Z"
    },
    {
      "id": "https://boot-error.github.io/post/plain_jane_writeup/",
      "url": "https://boot-error.github.io/post/plain_jane_writeup/",
      "title": "AUCTF writeup - plain_jane",
      "content_html": "<p class=\"markdown\">In <a href=\"https://ctf.auburn.edu/\" class=\"markdown\">AUCTF 2020</a> under <code>rev</code> section, the challenge <a href=\"https://github.com/auehc/AUCTF-2020/blob/master/Reversing/Plain%20Jane/prompt.md\" class=\"markdown\">plain jane</a> had a assembly code. It said, we need to figure out what the program returns.</p> <p class=\"markdown\">Here's what I did.</p> <p class=\"markdown\">First, compile it to binary using <code>gcc</code></p> <h3 id=\"compile\" class=\"markdown\">Compile <a class=\"header-anchor markdown\" href=\"#compile\">↩</a></h3> <pre class=\"language-shell\"><code class=\"language-shell\">gcc -o plain_jane plain_jane.s</code></pre> <p class=\"markdown\">Then open the binary in radare.</p> <h3 id=\"recon\" class=\"markdown\">Recon <a class=\"header-anchor markdown\" href=\"#recon\">↩</a></h3> <pre><code>o plain_jane aaa i </code></pre> <pre><code>fd       7 file     plain_jane size     0x4040 humansz  16.1K mode     r-x format   elf64 iorw     false blksz    0x0 block    0x100 type     DYN (Shared object file) arch     x86 baddr    0x0 binsz    14714 bintype  elf bits     64 canary   false class    ELF64 compiler GCC: (Arch Linux 9.3.0-1) 9.3.0/GCC: (Debian 9.2.1-22) 9.2.1 20200104 crypto   false endian   little havecode true intrp    /lib64/ld-linux-x86-64.so.2 laddr    0x0 lang     c linenum  true lsyms    true machine  AMD x86-64 architecture maxopsz  16 minopsz  1 nx       true os       linux pcalign  0 pic      true relocs   true relro    partial rpath    NONE sanitiz  false static   false stripped false subsys   linux va       true </code></pre> <pre><code>aflm </code></pre> <pre><code>entry0:     reloc.__libc_start_main  entry.fini0:     reloc.__cxa_finalize     rip  sym.__libc_csu_init:     sym._init     rdx  main:     sym.func_1     sym.func_2     sym.func_3 </code></pre> <p class=\"markdown\">So we have <code>main</code> calling 3 functions <code>func_1</code>, <code>func_2</code> and <code>func_3</code></p> <pre><code>s main pdf </code></pre> <pre><code>┌ 59: int main (int argc, char **argv, char **envp); │           ; var int64_t var_ch @ rbp-0xc │           ; var int64_t var_8h @ rbp-0x8 │           ; var int64_t var_4h @ rbp-0x4 │           ; DATA XREF from entry0 @ 0x1041 │           0x00001119      55             push rbp │           0x0000111a      4889e5         mov rbp, rsp │           0x0000111d      4883ec10       sub rsp, 0x10 │           0x00001121      b800000000     mov eax, 0 │           0x00001126      e829000000     call sym.func_1 │           0x0000112b      8945fc         mov dword [var_4h], eax │           0x0000112e      b800000000     mov eax, 0 │           0x00001133      e85e000000     call sym.func_2 │           0x00001138      8945f8         mov dword [var_8h], eax │           0x0000113b      8b55f8         mov edx, dword [var_8h] │           0x0000113e      8b45fc         mov eax, dword [var_4h] │           0x00001141      89d6           mov esi, edx │           0x00001143      89c7           mov edi, eax │           0x00001145      e85c000000     call sym.func_3 │           0x0000114a      8945f4         mov dword [var_ch], eax │           0x0000114d      b800000000     mov eax, 0 │           0x00001152      c9             leave └           0x00001153      c3             ret </code></pre> <p class=\"markdown\">Disassembly of <code>main</code> shows us these calls being made and the parameters passed.</p> <p class=\"markdown\">Now since we need to know what the program returns, find the location where the final output of the program is stored. The final computation is returned by the <code>func_3</code> fn call, where the output is pushed to stack at <code>rbp-0xc</code>.</p> <p class=\"markdown\">Running the program in debugger and setting a breakpoint at <code>0x0000114a</code> should give us the output we have been looking for.</p> <h3 id=\"debug-to-get-the-flag\" class=\"markdown\">Debug to get the flag <a class=\"header-anchor markdown\" href=\"#debug-to-get-the-flag\">↩</a></h3> <pre><code>ood s main pdf </code></pre> <pre><code>7380 ┌ 59: int main (int argc, char **argv, char **envp); │           ; var int64_t var_ch @ rbp-0xc │           ; var int64_t var_8h @ rbp-0x8 │           ; var int64_t var_4h @ rbp-0x4 │           ; DATA XREF from entry0 @ 0x55c1cd642041 │           0x55c1cd642119      55             push rbp │           0x55c1cd64211a      4889e5         mov rbp, rsp │           0x55c1cd64211d      4883ec10       sub rsp, 0x10 │           0x55c1cd642121      b800000000     mov eax, 0 │           0x55c1cd642126      e829000000     call sym.func_1 │           0x55c1cd64212b      8945fc         mov dword [var_4h], eax │           0x55c1cd64212e      b800000000     mov eax, 0 │           0x55c1cd642133      e85e000000     call sym.func_2 │           0x55c1cd642138      8945f8         mov dword [var_8h], eax │           0x55c1cd64213b      8b55f8         mov edx, dword [var_8h] │           0x55c1cd64213e      8b45fc         mov eax, dword [var_4h] │           0x55c1cd642141      89d6           mov esi, edx │           0x55c1cd642143      89c7           mov edi, eax │           0x55c1cd642145      e85c000000     call sym.func_3 │           0x55c1cd64214a      8945f4         mov dword [var_ch], eax │           0x55c1cd64214d      b800000000     mov eax, 0 │           0x55c1cd642152      c9             leave └           0x55c1cd642153      c3             ret </code></pre> <pre><code>dcu 0x55c1cd64214a </code></pre> <p class=\"markdown\">At this state, the value returned from <code>func_3</code> is stored in <code>eax</code> register. Let's inspect the registers.</p> <pre><code>dr </code></pre> <pre><code>rax = 0x00006fcf rbx = 0x55c1cd642250 rcx = 0x7fa9d9097578 rdx = 0xffffffb6 r8 = 0x00000000 r9 = 0x7fa9d90d5260 r10 = 0x00000003 r11 = 0x00000002 r12 = 0x55c1cd642020 r13 = 0x7fff4914ae50 r14 = 0x00000000 r15 = 0x00000000 rsi = 0x000000cf rdi = 0x00000042 rsp = 0x7fff4914ad50 rbp = 0x7fff4914ad60 rip = 0x55c1cd64214a rflags = 0x00000246 orax = 0xffffffffffffffff </code></pre> <p class=\"markdown\">In <code>x86_64</code>, the <code>rax</code> register's lower half i.e the 32bits from LSB is the value stored in <code>eax</code>. On converting <code>0x6fcf</code> into a decimal, we should get the flag.</p> <pre><code>? 0x6fcf </code></pre> <pre><code>int32   28623 uint32  28623 hex     0x6fcf octal   067717 unit    28.0K segment 0000:0fcf string  &quot;\\xcfo&quot; fvalue: 28623.0 float:  0.000000f double: 0.000000 binary  0b0110111111001111 trits   0t1110021010 </code></pre> <p class=\"markdown\">The flag is <em>28623</em></p> ",
      "date_published": "2020-04-06T00:00:00.000Z"
    },
    {
      "id": "https://boot-error.github.io/post/wfh_hack_using_attiny85/",
      "url": "https://boot-error.github.io/post/wfh_hack_using_attiny85/",
      "title": "WFH Hack with Attiny85",
      "content_html": "<p class=\"markdown\">I'm restricted to using my Work Laptop for everything related to work and it's all great and usual, but with a minor inconvenience. The laptop hibernates after couple of minutes of inactivity, and If walk away for a coffee, I'll miss on important notification, delaying my response.</p> <p class=\"markdown\">And I can't change the screensaver settings, which is acceptable. Hence, I came up with this hack.</p> <!-- more --> <h3 id=\"my-smart-friend's-hack\" class=\"markdown\">My Smart friend's hack <a class=\"header-anchor markdown\" href=\"#my-smart-friend's-hack\">↩</a></h3> <p class=\"markdown\">A friend of mine came up with a simple hack, where he would place his Analog Watch underneath the mouse's optical sensor. The movement of the second hand would constantly trigger some mouse activity which stops his laptop from hibernating.</p> <p class=\"markdown\">This is great, but I felt it too tedious and I didn't have a watch (duh I got my smartphone to check time). I need a better solution.</p> <h2 id=\"meet-attiny85\" class=\"markdown\">Meet Attiny85 <a class=\"header-anchor markdown\" href=\"#meet-attiny85\">↩</a></h2> <p class=\"markdown\">Attiny85 is an Atmega Series microcontroller and the package above is size of a thumb with a PCB craved out like a USB port. I can write Arduino code which can run on this tiny microcontroller. This includes writing a programmable USB HID 😈</p> <div class=\"image-container\"><img src=\"https://boot-error.github.io/img/digispark_attiny85.jpg\" alt=\"Attiny 85\" class=\"markdown\"></div> <p class=\"markdown\">I had one lying around, time to build one.</p> <h2 id=\"the-mouse-jiggler\" class=\"markdown\">The Mouse Jiggler <a class=\"header-anchor markdown\" href=\"#the-mouse-jiggler\">↩</a></h2> <p class=\"markdown\">To trick my laptop into thinking I'm using it, the Attiny 85 program does the following in bare minimum</p> <ul class=\"markdown\"> <li class=\"markdown\">For Every 2 minutes, <ul class=\"markdown\"> <li class=\"markdown\">move the mouse pointer to any direction</li> <li class=\"markdown\">move the mouse pointer back to where it was</li> </ul> </li> </ul> <p class=\"markdown\">For the computer, this is a mouse activity meaning the user is active. The computer would reset its screen saver timeout.</p> <p class=\"markdown\">Follow instructions <a href=\"https://www.instructables.com/Digispark-Attiny-85-With-Arduino-IDE/\" class=\"markdown\">here</a> to setup Arduino IDE for programming this board</p> <p class=\"markdown\">Here is the code, the phantom user to my computer!</p> <pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;DigiMouse.h></span></span><br><br><span class=\"token comment\">// wait for DELAY_MINUTES, this is less than your</span><br><span class=\"token comment\">// screen saver's timeout</span><br><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">DELAY_MINUTES</span> <span class=\"token expression\"><span class=\"token number\">2</span></span></span><br><br><span class=\"token keyword\">void</span> <span class=\"token function\">setup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><br>  DigiMouse<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>  <span class=\"token function\">pinMode</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> OUTPUT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br> <br><span class=\"token keyword\">void</span> <span class=\"token function\">loop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">// blinks the on-board LED to indicate mouse movement</span><br>    <span class=\"token function\">digitalWrite</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> HIGH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token comment\">// moves the cursor right 30px</span><br>    DigiMouse<span class=\"token punctuation\">.</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span> <span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    DigiMouse<span class=\"token punctuation\">.</span><span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token comment\">// move the cursor left 30px</span><br>    DigiMouse<span class=\"token punctuation\">.</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token function\">digitalWrite</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> LOW<span class=\"token punctuation\">)</span><br>    DigiMouse<span class=\"token punctuation\">.</span><span class=\"token function\">delay</span><span class=\"token punctuation\">(</span>DELAY_MINUTES <span class=\"token operator\">*</span> <span class=\"token number\">60000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>  <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre> <p class=\"markdown\">Compile and upload the sketch and watch your computer tricked into thinking you are always working!</p> <p class=\"markdown\">This Mouse Jiggler won't even interrupt while you are working since it's actions are so swift, unless you do a lot of art using mouse then prepare for some erroneous lines in your drawings.</p> ",
      "date_published": "2021-03-25T00:00:00.000Z"
    }
  ]
}